<!DOCTYPE html>
<html>
<head>
  <title>visualizer</title>
</head>
<body>
  <canvas id="mainCanvas" width="640", height="480">oops ur browser bad</canvas>

  <br/>

  <button id="resetButton">clear</button>

  <br/>

  <button id="resetAnimButton">reset</button>
  <button id="nextButton">next</button>
  <button id="fastButton">fast</button>
</body>
<script src="./lodash.js"></script>
<script type="text/javascript">
  resetButton.onclick = resetPoints
  resetAnimButton.onclick = resetAnimation
  nextButton.onclick = advanceAnimation
  fastButton.onclick = fastAnimation
  mainCanvas.onclick = addPoint
  window.onload = init

  let points = [
    {x: 1*48, y: 1*48},
    {x: 1*48, y: 6*48},
    {x: 8*48, y: 3*48},
    {x: 3*48, y: 4*48},
    {x: 5*48, y: 5*48},
    {x: 8*48, y: 9*48},
  ]
  points = [{x: 349, y: 332}, {x: 265, y: 329}, {x: 327, y: 280}, {x: 264, y: 325}, {x: 253, y: 327}, {x: 253, y: 332}, {x: 260, y: 332}, {x: 262, y: 331}, {x: 262, y: 327}, {x: 259, y: 326}, {x: 257, y: 329}, {x: 257, y: 331}, {x: 266, y: 322}, {x: 327, y: 271}, {x: 320, y: 275}, {x: 320, y: 284}, {x: 331, y: 279}, {x: 331, y: 275}, {x: 319, y: 283}, {x: 326, y: 283}, {x: 327, y: 280}, {x: 324, y: 283}, {x: 342, y: 325}, {x: 342, y: 333}, {x: 348, y: 336}, {x: 354, y: 324}, {x: 344, y: 323}, {x: 343, y: 330}, {x: 351, y: 322}, {x: 311, y: 303}]

  let ctx
  let animTimer
  let stack = [] // used for animation
  let toVisit = []

  function cls() {
    ctx.fillStyle = 'lightgray';
    ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height)
  }

  function argminBy(arr, f) {
    if (arr.length === 0) {
      return undefined
    }
    argmin = 0
    min = f(arr[0])
    for (var i = 1; i < arr.length; i++) {
      elem = f(arr[i])
      // console.log({i, elem, min});
      if (elem < min) {
        argmin = i
        min = elem
      }
    }
    return argmin
  }

  // Three points are a counter-clockwise turn if ccw > 0, clockwise if
  // ccw < 0, and collinear if ccw = 0 because ccw is a determinant that
  // gives twice the signed  area of the triangle formed by p1, p2 and p3.
  function ccw(p1, p2, p3) {
    // (sign flipped from wiki b/c of game coordinates)
    return -((p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x))
  }

  function stackCcw(ix1, ix2, ix3) {
    if (ix1 < 0) {
      ix1 = ix1 + stack.length
    }
    if (ix2 < 0) {
      ix2 += stack.length
    }
    if (ix3 < 0) {
      ix3 += stack.length
    }
    return ccw(stack[ix1], stack[ix2], stack[ix3])
  }

  // slope of line from p1 to p2. remember that we're using game coords
  function angle(p1, p2) {
    return Math.atan2(p2.y-p1.y, p2.x-p1.x)
  }

  function line(p1, p2, color=undefined) {
    // console.log({p1, p2, color});
    if (color) {
      ctx.strokeStyle = color;
    }
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
  }

  function ctxWith(prop, val, cb) {
    const old = ctx[prop]
    ctx[prop] = val
    cb()
    ctx[prop] = old
  }


  function doubleCheck() {
    if (stack.length > 2) {
      for (var i = 0; i < stack.length; i++) {
        // console.log({i, ccw: stackCcw(i-2, i-1, i)});
        if (stackCcw(i-2, i-1, i) <= 0) { // TODO: will throw error when they're colinear but maybe not the same point
          console.error("error", i-2, i-1, i)
          console.error({stack})
          ctxWith('lineWidth', 10, () => {
            drawOneStackLine(i-2, i-1, 'red')
            drawOneStackLine(i-1, i, 'red')
            drawOneStackLine(i, i-2, 'red')
          })
        }
      }
    }
  }

  function fastAnimation() {
    resetAnimation()
    animTimer = setInterval(() => {
      if (!advanceAnimation()) {
        clearInterval(animTimer)
      }
    }, 50)
  }

  function resetAnimation() {
    clearInterval(animTimer)
    stack = []
    toVisit = []
    cls()
    drawPoints()
  }

  // returns whether there's more to do
  function advanceAnimation() {
    cls()
    drawPoints()
    // console.log("advanceAnimation", stack)
    drawFullStack('black')

    if (stack.length === 0) {
      // console.log("inside");
      const i = argminBy(points, p=>p.y)
      const start = points[i]
      toVisit = [...points.slice(0, i), ...points.slice(i+1, points.length)]
      toVisit = _.chain(toVisit)
        .sortBy(p=>angle(start, p))
        .sortedUniqBy(p=>`x${p.x}y${p.y}`) // slow
        .value()
      // console.log({stack})
      // console.log({toVisit})

      stack.push(start)
    }
    // console.log({stack})
    // console.log({toVisit})
    if (stack.length > 2) {
      const det = stackCcw(-3, -2, -1)
      if (det < 0) {
        const toPush = stack.pop()
        stack.pop()
        stack.push(toPush)
        drawOneStackLine(-2, -1, 'red')
        return true
      }
    }
    if (toVisit.length === 0) {
      drawOneStackLine(-1, 0, 'black')
      console.log("done");
      doubleCheck()
      return false
    } else {
      stack.push(toVisit.pop())
      drawOneStackLine(-2, -1, 'blue')
      return true
    }
  }

  function drawFullStack(color) {
    for (var i = 1; i < stack.length; i++) {
      drawOneStackLine(i-1, i, color)
    }
  }

  // draws a line between the indices of points on the stack
  function drawOneStackLine(ix1, ix2, color) {
    if (ix1 < 0) {
      ix1 = ix1 + stack.length
    }
    if (ix2 < 0) {
      ix2 += stack.length
    }
    line(stack[ix1], stack[ix2], color)
  }

  function addPoint(e) {
    resetAnimation()
    points.push({x: e.offsetX, y: e.offsetY})
    cls()
    drawPoints()
  }

  function drawPoints() {
    for (var i = 0; i < points.length; i++) {
      const {x, y} = points[i]
      ctx.beginPath()
      ctx.arc(x, y, 2, 0, 2 * Math.PI)
      ctx.fillStyle = 'black';
      ctx.fill()
    }
  }

  function init() {
    ctx = mainCanvas.getContext('2d')
    cls()
    drawPoints()
  }

  function resetPoints() {
    points = []
    cls()
  }
</script>
<style type="text/css">
  canvas {
    border: 1px solid black;
  }
</style>
</html>